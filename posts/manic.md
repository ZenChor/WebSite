---
title: Going Manic
date: '2025-01-15'
---

A decade ago, I found myself in Germany, an Australian mechanical engineering student with time to spare before university began. Between wrestling with bureaucracy and learning to pronounce "Streichholzsch√§chtelchen," I turned to programming. Stack Overflow suggested Python was a good place to start, and who was I to argue with the collective wisdom of the internet? What I didn't realize then was how the parallel between learning German and learning to program would become so instructive - in both domains, those who practice actively and embrace their mistakes are the ones who truly progress.

The beautiful thing about being a beginner is that you don't know what you don't know. My first real project emerged from watching myself try to organize information while researching universities and learning German. I wanted to create a note-taking application that would free us from having to remember where we put things - a system where hotkeys would automatically bind notes to windows and applications. A democratic approach to information organization, though I wouldn't have called it that at the time.

Nine months and three frameworks later - from tkinter to kivy to neovim - I had something semi-functional. It could bind to hotkeys, create and load pages. But more importantly, it taught me my first lesson about the gap between vision and implementation. Performance issues with neovim integration weren't just technical problems; they were signposts pointing to deeper waters I hadn't yet learned to navigate. It was also my first encounter with the unsatisfying feeling of using frameworks and libraries without truly understanding them - like trying to paint while wearing someone else's glasses.

Life has a way of introducing plot twists. Mental health challenges led me to leave university, but by then programming had become more than just a way to pass time. Two weeks of job hunting led to a position at a consultancy, where I encountered a colleague who declared, "I've been here for two years - I'm a senior developer!" It was a moment that crystallized something about our relationship with expertise - how we can simultaneously know so much and so little. During those two years, and two more at another company, I discovered the first paradox of freedom: when you have a job, you wish for the freedom to work on your own projects. Yet freedom, as I would later learn, comes with its own constraints.

It was during this time, about four years ago, that psilocybin mushrooms offered their own perspective on programming paradigms. Insights about reference and transformation, visions of new ways to think about computation. The experience left me with an ambitious vision for a project I call "manic" - a new kind of programming environment combining operating systems, languages, and AI in ways I'm still struggling to fully articulate. My connection to programming had become deeply personal, marked permanently in ink - one tattoo from Jonathan Blow's The Witness, a game about perspective and learning that seemed to understand me on a deep level (though maybe I was just being manic), another of the Clojure language symbol.

Meanwhile, a new idea was germinating, sparked by watching someone confidently playing music for an entire office. There's something fascinating about the social dynamics of shared spaces and shared experiences. Zencore emerged from this observation - a vision of democratizing music sharing, making it more egalitarian, less intimidating. The idea is six years old now, though it's only been two months of full-time work.

Recently, I watched Sputnik's video about evolutionary algorithms, and something clicked - I wanted to create something similar. It wasn't directly related to Zencore's business needs, but the energy was there, pulling me toward it. Following this energy led me straight into the limits of my knowledge - my implementation runs with all the grace of a sloth doing calculus.

This desire to create, to follow the energy of inspiration while balancing business needs, led me to Casey Muratori's performance-aware programming course and Jonathan Blow's Jai language. Joining the Jai beta has been particularly inspiring - there's a dedication to quality, a commitment to understanding systems deeply, that resonates strongly with where I want to go. There's so much to learn: caching, branching, virtual pages, assembly language. I'm still a noob at making things truly perform well, at working without garbage collection, at utilizing GPUs effectively.

I dream of building Zencore with fewer layers, fewer frameworks, more direct engagement with the machine. Perhaps there's even a business case for this level of performance optimization - offering users an experience that's not just functional but fluid, efficient, respectful of their resources. It's a hope that bridges the gap between my desire for technical mastery and the practical needs of the business.

Being a noob doesn't bother me like it used to, because I'm doing something about it. The path forward is clearer now, even if it's longer than I once imagined. It reminds me of my early days learning German - the students who made mistakes, who practiced actively, who engaged with the language even when it was uncomfortable, they were the ones who improved. The same holds true in programming; real growth comes not from passive consumption but from active engagement with the hard parts.

And somewhere in the future lies the manic project - a mountain so vast it would take ten PhDs a decade to climb. Just getting up to date with abstract interpretation and AI advancements would be a journey in itself, let alone forging new ground. It's not an immediate goal - it's far too daunting for that - but a north star, a reminder that our reach should exceed our grasp.

It's a dance between pragmatism and vision, between the code that ships and the code that could be. Some days I'm implementing practical features for Zencore, others I'm diving into Casey's course, understanding computers at a deeper level. Both are necessary. Both are part of the journey. After all, isn't that what a programmer is? Part craftsperson, part dreamer, writing the future one line at a time, even if we're not quite sure where all those lines will lead.
